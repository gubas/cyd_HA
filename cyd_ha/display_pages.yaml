# Stable version + auto-cycling pages (3 screens) on top of classic menu
# Keep original display config, add simple page management + i18n labels

display:
  - platform: ili9xxx
    id: esp_display
    model: ili9342
    spi_id: tft
    cs_pin: GPIO15
    dc_pin: GPIO2
    invert_colors: false
    color_palette: 8BIT
    dimensions:
      width: 320
      height: 240
    rotation: 90
    update_interval: 500ms
    lambda: |-
      // Use the global current_page instead of a static local variable
      int page = id(current_page);
      static unsigned long last_switch = 0;
      static bool initialized = false;
      const int PAGE_COUNT = 3;
      
      // Initialize on first call
      if (!initialized) {
        last_switch = millis();
        initialized = true;
      }
      
      // Auto-cycle every 8 seconds
      if (!id(show_return_page)) {
        if (millis() - last_switch > 8000) {
          id(current_page) = (id(current_page) + 1) % PAGE_COUNT;
          page = id(current_page);
          last_switch = millis();
        }
      } else {
      // Reset timer while in menu
        last_switch = millis();
      }
      
      // Classic menu when requested
      if (id(show_return_page)) {
        it.fill(id(black));
        // Reset du timer quand on est dans le menu
        last_switch = millis();
        const int MENU_W = 240;
        const int HEADER_MARGIN = 10;
        const int HEADER_Y = 10;
        const int button_width = 100;
        const int button_height = 65;
        const int x_start = 15;
        const int y_start = 15;
        const int x_padding = 10;
        const int y_padding = 10;
        const char* button_texts[] = {
          "${btn1_label}",
          "${btn2_label}",
          "${btn3_label}",
          "${btn4_label}",
          "${btn5_label}",
          "${btn6_label}",
          "${btn7_label}",
          "${btn8_label}"
        };
        for (int row = 0; row < 4; row++) {
          for (int col = 0; col < 2; col++) {
            int idx = row * 2 + col;
            int x = x_start + col * (button_width + x_padding);
            int y = y_start + row * (button_height + y_padding);
            it.filled_rectangle(x, y, button_width, button_height, id(card_bg));
            it.rectangle(x, y, button_width, button_height, id(divider));
            int text_width = strlen(button_texts[idx]) * 5.5;
            int text_height = 16;
            it.print(x + (button_width - text_width) / 2,
                     y + (button_height - text_height) / 2 + 20,
                     id(buttons),
                     id(white),
                     button_texts[idx]);
          }
        }
        // Icons
        if (id(button1_entity_color).has_state() && id(button1_entity_color).state == "on") {
          it.image(45, 20, id(up), id(blue));
        } else {
          it.image(45, 20, id(up), id(grey));
        }
        if (id(button2_entity_color).has_state() && id(button2_entity_color).state == "on") {
          it.image(155, 20, id(meeting), id(blue));
        } else {
          it.image(155, 20, id(meeting), id(grey));
        }
        if (id(button3_entity_color).has_state() && id(button3_entity_color).state == "on") {
          it.image(45, 95, id(stop), id(blue));
        } else {
          it.image(45, 95, id(stop), id(grey));
        }
        if (id(button4_entity_color).has_state() && id(button4_entity_color).state == "on") {
          it.image(155, 95, id(lampadaire), id(blue));
        } else {
          it.image(155, 95, id(lampadaire), id(grey));
        }
        if (id(button5_entity_color).has_state() && id(button5_entity_color).state == "on") {
          it.image(45, 170, id(down), id(blue));
        } else {
          it.image(45, 170, id(down), id(grey));
        }
        if (id(button6_entity_color).has_state() && id(button6_entity_color).state == "on") {
          it.image(155, 170, id(printer3d), id(blue));
        } else {
          it.image(155, 170, id(printer3d), id(grey));
        }
        if (id(button7_entity_color).has_state() && id(button7_entity_color).state == "on") {
          it.image(45, 245, id(bulb), id(blue));
        } else {
          it.image(45, 245, id(bulb), id(grey));
        }
        it.image(155, 245, id(back), id(grey));
        return;
      }
      // Render pages (3 screens)
      it.fill(id(black));
      // Portrait fixed dimensions (rotation 90 swaps driver W/H)
      const int W = 240;
      const int H = 320;
      const int CX = W / 2;
      const int M = 14;
      const int HEADER_MARGIN = 10;
      const int HEADER_Y = 10;
      it.print(HEADER_MARGIN, HEADER_Y, id(info), id(white), TextAlign::TOP_LEFT, "${device_friendly_name}");
      it.strftime(W - HEADER_MARGIN, HEADER_Y, id(info), id(white), TextAlign::TOP_RIGHT, "%d/%m %H:%M", id(esptime).now());
      const int TITLE_Y = 64;
      if (page == 0) {
        // Page 1: Weather — App style
        it.printf(CX, TITLE_Y - 10, id(info), id(white), TextAlign::CENTER, "%s — %s", "${i18n_weather_title}", "${location_name}");
        
      // Top section: Weather icon + Temperature + Humidity
        const int ICON_Y = 90;
        const int ICON_SIZE_BIG = 60;
        
      // Big weather icon (left) with lightweight animation (Option A)
        if (id(weather_state).has_state()) {
          static std::map<std::string, std::string> weather_icon_map = {
            {"clear-night", "\U000F0594"}, {"cloudy", "\U000F0590"}, {"fog", "\U000F0591"},
            {"hail", "\U000F0592"}, {"lightning", "\U000F0593"}, {"lightning-rainy", "\U000F067E"},
            {"partlycloudy", "\U000F0595"}, {"pouring", "\U000F0596"}, {"rainy", "\U000F0597"},
            {"snowy", "\U000F0598"}, {"snowy-rainy", "\U000F067F"}, {"sunny", "\U000F0599"},
            {"windy", "\U000F059D"}, {"windy-variant", "\U000F059E"},
          };
          const std::string& ws = id(weather_state).state;
          auto itw = weather_icon_map.find(ws);
          const char* icon = (itw != weather_icon_map.end()) ? itw->second.c_str() : "\U000F0599";

          // Simple 2-frame toggle every 500ms + 1px bounce for dynamic conditions
          unsigned long t = millis();
          bool phase = ((t / 500) % 2) == 0;
          bool is_dynamic = (
            ws == "rainy" || ws == "pouring" ||
            ws == "lightning" || ws == "lightning-rainy" ||
            ws == "windy" || ws == "windy-variant" ||
            ws == "snowy" || ws == "snowy-rainy" ||
            ws == "hail"
          );

          if (phase) {
            if (ws == "rainy") icon = "\U000F0596";            // rainy ↔ pouring
            else if (ws == "pouring") icon = "\U000F0597";
            else if (ws == "lightning") icon = "\U000F067E";  // lightning ↔ lightning-rainy
            else if (ws == "lightning-rainy") icon = "\U000F0593";
            else if (ws == "windy") icon = "\U000F059E";      // windy ↔ windy-variant
            else if (ws == "windy-variant") icon = "\U000F059D";
            else if (ws == "snowy") icon = "\U000F067F";      // snowy ↔ snowy-rainy
            else if (ws == "snowy-rainy") icon = "\U000F0598";
          }

          int icon_y = ICON_Y + (is_dynamic && phase ? 1 : 0);
          it.printf(50, icon_y, id(fontmeteo), id(blue), TextAlign::CENTER, icon);
        } else {
          it.printf(50, ICON_Y, id(fontmeteo), id(blue), TextAlign::CENTER, "\U000F0599");
        }
        
      // Temperature with icon (right)
        it.image(W - 100, ICON_Y - 10, id(temp_small), id(blue));
        if (id(temp_ext).has_state()) {
          it.printf(W - 70, ICON_Y, id(info), id(white), TextAlign::CENTER_LEFT, "%.1f°C", id(temp_ext).state);
        } else {
          it.print(W - 70, ICON_Y, id(info), id(white), TextAlign::CENTER_LEFT, "--°C");
        }
        
      // Humidity (below temperature)
        it.image(W - 100, ICON_Y + 15, id(humidity_small), id(blue));
        if (id(humidity_ext).has_state()) {
          it.printf(W - 70, ICON_Y + 25, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f %%", id(humidity_ext).state);
        }

      // Weather alerts (line below the icon)
        const int ALERT_Y = 135;
        static char alert_buffer[100];
        alert_buffer[0] = '\0';
        bool has_alert = false;
        
        if (id(alert_vent).has_state() && id(alert_vent).state != "Vert" && id(alert_vent).state != "vert") {
          sprintf(alert_buffer + strlen(alert_buffer), "Vent(%s) ", id(alert_vent).state.c_str());
          has_alert = true;
        }
        if (id(alert_pluie).has_state() && id(alert_pluie).state != "Vert" && id(alert_pluie).state != "vert") {
          if (has_alert) strcat(alert_buffer, "| ");
          sprintf(alert_buffer + strlen(alert_buffer), "Pluie(%s) ", id(alert_pluie).state.c_str());
          has_alert = true;
        }
        if (id(alert_orages).has_state() && id(alert_orages).state != "Vert" && id(alert_orages).state != "vert") {
          if (has_alert) strcat(alert_buffer, "| ");
          sprintf(alert_buffer + strlen(alert_buffer), "Orage(%s) ", id(alert_orages).state.c_str());
          has_alert = true;
        }
        if (id(alert_neige).has_state() && id(alert_neige).state != "Vert" && id(alert_neige).state != "vert") {
          if (has_alert) strcat(alert_buffer, "| ");
          sprintf(alert_buffer + strlen(alert_buffer), "Neige(%s) ", id(alert_neige).state.c_str());
          has_alert = true;
        }
        if (id(alert_inondation).has_state() && id(alert_inondation).state != "Vert" && id(alert_inondation).state != "vert") {
          if (has_alert) strcat(alert_buffer, "| ");
          sprintf(alert_buffer + strlen(alert_buffer), "Inond(%s) ", id(alert_inondation).state.c_str());
          has_alert = true;
        }
        
        if (has_alert) {
          it.printf(CX, ALERT_Y, id(info), id(white), TextAlign::CENTER, "%s", alert_buffer);
        } else {
          it.print(CX, ALERT_Y, id(info), id(white), TextAlign::CENTER, "${i18n_no_alerts}");
        }

      // Rain forecast (rectangles)
        const int RAIN_Y = ALERT_Y + 20;
        const int RECT_W_5 = 16;   // 6 premiers (5 min)
        const int RECT_W_10 = 32;  // 3 derniers (10 min)
        const int RECT_H = 8;
        const int RECT_SPACING = 3;
        const int TOTAL_RAIN_W = 6 * RECT_W_5 + 3 * RECT_W_10 + 8 * RECT_SPACING;
        const int RAIN_START_X = (W - TOTAL_RAIN_W) / 2;
        
      // Extract value for a key inside the attribute raw text
        auto extract_forecast = [&](const std::string& data, const char* key) -> std::string {
          if (data.empty()) return "Temps sec";
          std::string search_key = std::string("'") + key + "'";
          size_t pos = data.find(search_key);
          if (pos == std::string::npos) {
            // Essayer avec guillemets doubles
            search_key = std::string("\"") + key + "\"";
            pos = data.find(search_key);
          }
          if (pos == std::string::npos) return "Temps sec";
          
          // Chercher ':' après la clé
          size_t colon = data.find(':', pos);
          if (colon == std::string::npos) return "Temps sec";
          
          // Chercher le début de la valeur (après : et espaces/guillemets)
          size_t val_start = colon + 1;
          while (val_start < data.size() && (data[val_start] == ' ' || data[val_start] == '\'' || data[val_start] == '"')) {
            val_start++;
          }
          
          // Chercher la fin de la valeur (virgule, guillemet, ou accolade)
          size_t val_end = val_start;
          while (val_end < data.size() && data[val_end] != ',' && data[val_end] != '\'' && data[val_end] != '"' && data[val_end] != '}') {
            val_end++;
          }
          
          return data.substr(val_start, val_end - val_start);
        };
        
      // Map rain intensity to color (BGR order for this display)
        auto get_rain_color = [&](const std::string& rain_type) -> Color {
          std::string lower_type;
          for (char c : rain_type) {
            lower_type += tolower(c);
          }
          
          if (lower_type.find("forte") != std::string::npos || lower_type.find("fort") != std::string::npos) {
            return Color(150, 50, 0);  // Bleu foncé (BGR)
          }
          if (lower_type.find("mod") != std::string::npos) {
            return Color(180, 100, 50);  // Bleu moyen (BGR)
          }
          if (lower_type.find("faible") != std::string::npos) {
            return Color(200, 150, 100);  // Bleu clair (BGR)
          }
          return Color(255, 255, 255);  // Blanc (temps sec)
        };

      // Get forecast raw data
        std::string forecast_data = id(next_rain_forecast_data).has_state() ? id(next_rain_forecast_data).state : "";
        
      // Debug log once (not every frame)
        static bool logged_once = false;
        if (!logged_once && !forecast_data.empty()) {
          ESP_LOGD("rain_forecast", "Data: %s", forecast_data.c_str());
          logged_once = true;
        }
        
      // Extract each interval and draw
        const char* intervals[] = {"0 min", "5 min", "10 min", "15 min", "20 min", "25 min", "35 min", "45 min", "55 min"};
        int rect_x = RAIN_START_X;
        
        for (int i = 0; i < 9; i++) {
          std::string rain_value = extract_forecast(forecast_data, intervals[i]);
          
          // Decide fill vs empty (dry => empty)
          std::string lower_val;
          for (char c : rain_value) lower_val += tolower(c);
          bool is_dry = (lower_val.find("sec") != std::string::npos);
          const int rect_w = (i < 6) ? RECT_W_5 : RECT_W_10;
          
          if (is_dry) {
            // Dry: empty rectangle (grey border)
            it.rectangle(rect_x, RAIN_Y, rect_w, RECT_H, id(grey));
          } else {
            // Rain: filled rectangle with mapped color
            Color fill_color = get_rain_color(rain_value);
            it.filled_rectangle(rect_x, RAIN_Y, rect_w, RECT_H, fill_color);
            it.rectangle(rect_x, RAIN_Y, rect_w, RECT_H, id(grey));
          }
          rect_x += rect_w + RECT_SPACING;
        }

      // Time labels under bars
        int label_x = RAIN_START_X;
        for (int i = 0; i < 9; i++) {
          const int rect_w = (i < 6) ? RECT_W_5 : RECT_W_10;
          int cx = label_x + rect_w / 2;
          const char* lab = intervals[i];
          char num[4]; int j = 0;
          for (const char* p = lab; *p && j < 3; ++p) {
            if (*p >= '0' && *p <= '9') num[j++] = *p;
            else break;
          }
          num[j] = 0;
          it.printf(cx, RAIN_Y + RECT_H + 1, id(info), id(grey), TextAlign::TOP_CENTER, "%s", num);
          label_x += rect_w + RECT_SPACING;
        }

      // Text: next rain
        std::string next_label = "";
        for (int i = 0; i < 9; i++) {
          std::string val = extract_forecast(forecast_data, intervals[i]);
          std::string v;
          for (char c : val) v += tolower(c);
          if (!v.empty() && v.find("sec") == std::string::npos) {
            next_label = intervals[i];
            break;
          }
        }
        const int NEXT_TEXT_Y = RAIN_Y + RECT_H + 30;
        if (!next_label.empty()) {
          it.printf(CX, NEXT_TEXT_Y, id(info), id(white), TextAlign::CENTER, "%s: %s", "${i18n_next_rain_prefix}", next_label.c_str());
        } else {
          it.print(CX, NEXT_TEXT_Y, id(info), id(white), TextAlign::CENTER, "${i18n_next_rain_none}");
        }


        // Grille d'informations météo (6 données en 3x2)
        const int GRID_START_Y = 200;
        const int ROW_HEIGHT = 22;
        const int COL1_X = 20;
        const int COL2_X = 118; // décalé vers la gauche pour éviter les coupures
        const int ICON_SIZE = 20;
        const int TEXT_OFFSET = 22;
        
      // Row 1: Rain | Wind (direction + speed)
        it.image(COL1_X, GRID_START_Y, id(umbrella), id(blue));
        if (id(rainchance).has_state()) it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f %%", id(rainchance).state);
        else it.print(COL1_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- %");
        
        // Wind: display cardinal direction letters
        if (id(wind_bearing).has_state() && id(wind_speed).has_state()) {
          float bearing = id(wind_bearing).state;
          // Convert bearing to cardinal direction
          const char* direction;
          if (bearing >= 337.5 || bearing < 22.5) direction = "N";
          else if (bearing >= 22.5 && bearing < 67.5) direction = "NE";
          else if (bearing >= 67.5 && bearing < 112.5) direction = "E";
          else if (bearing >= 112.5 && bearing < 157.5) direction = "SE";
          else if (bearing >= 157.5 && bearing < 202.5) direction = "S";
          else if (bearing >= 202.5 && bearing < 247.5) direction = "SW";
          else if (bearing >= 247.5 && bearing < 292.5) direction = "W";
          else direction = "NW";
          it.printf(COL2_X, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s %.0f km/h", direction, id(wind_speed).state);
        } else if (id(wind_speed).has_state()) {
          it.printf(COL2_X, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f km/h", id(wind_speed).state);
        } else {
          it.print(COL2_X, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- km/h");
        }
        
      // Row 2: Snow | Pressure
        it.image(COL1_X, GRID_START_Y + ROW_HEIGHT, id(snow_small), id(blue));
        if (id(snowchance).has_state()) it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f %%", id(snowchance).state);
        else it.print(COL1_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- %");
        
        it.image(COL2_X, GRID_START_Y + ROW_HEIGHT, id(pressure_small), id(blue));
        if (id(pressure).has_state()) it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f hPa", id(pressure).state);
        else it.print(COL2_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- hPa");
        
      // Row 3: Freeze
        it.image(COL1_X, GRID_START_Y + 2*ROW_HEIGHT, id(freeze_small), id(blue));
        if (id(freezechance).has_state()) it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + 2*ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f %%", id(freezechance).state);
        else it.print(COL1_X + TEXT_OFFSET, GRID_START_Y + 2*ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- %");
        
      // Row 4: Sunrise | Sunset
        it.image(COL1_X, GRID_START_Y + 3*ROW_HEIGHT, id(sunrise_small), id(blue));
        if (id(sunrise_time).has_state()) {
          // Parse ISO timestamp and extract HH:MM
          std::string sunrise_str = id(sunrise_time).state;
          size_t time_pos = sunrise_str.find('T');
          if (time_pos != std::string::npos && sunrise_str.length() > time_pos + 5) {
            std::string time_part = sunrise_str.substr(time_pos + 1, 5); // HH:MM
            it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + 3*ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s", time_part.c_str());
          }
        }
        
        it.image(COL2_X, GRID_START_Y + 3*ROW_HEIGHT, id(sunset_small), id(blue));
        if (id(sunset_time).has_state()) {
          std::string sunset_str = id(sunset_time).state;
          size_t time_pos = sunset_str.find('T');
          if (time_pos != std::string::npos && sunset_str.length() > time_pos + 5) {
            std::string time_part = sunset_str.substr(time_pos + 1, 5);
            it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + 3*ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s", time_part.c_str());
          }
        }
      } else if (page == 1) {
        // Page 2: Home sensors
        it.printf(CX, TITLE_Y, id(info), id(white), TextAlign::CENTER, "%s — %s", "${i18n_sensors_title}", "${location_name}");
        const int CARD_W = 210, CARD_H = 60, CARD_X = (W - CARD_W) / 2;
        const int C1_Y = 92, C2_Y = C1_Y + CARD_H + 12;
        it.filled_rectangle(CARD_X, C1_Y, CARD_W, CARD_H, id(card_bg));
        it.rectangle(CARD_X, C1_Y, CARD_W, CARD_H, id(divider));
        it.image(CARD_X + 8, C1_Y + 10, id(hometemperature), id(blue));
      it.print(CARD_X + 50, C1_Y + 12, id(info), id(white), "${room1_label}");
        if (id(temp_int).has_state()) it.printf(CARD_X + 50, C1_Y + 35, id(info), id(white), "%.1f C", id(temp_int).state);
        else it.print(CARD_X + 50, C1_Y + 35, id(info), id(white), "-- C");
        if (id(hum_int).has_state()) it.printf(CARD_X + 140, C1_Y + 35, id(info), id(white), "%.0f %%", id(hum_int).state);
        else it.print(CARD_X + 140, C1_Y + 35, id(info), id(white), "-- %");
        it.filled_rectangle(CARD_X, C2_Y, CARD_W, CARD_H, id(card_bg));
        it.rectangle(CARD_X, C2_Y, CARD_W, CARD_H, id(divider));
        it.image(CARD_X + 8, C2_Y + 10, id(deskroom), id(blue));
      it.print(CARD_X + 50, C2_Y + 12, id(info), id(white), "${room2_label}");
        if (id(int2_temp).has_state()) it.printf(CARD_X + 50, C2_Y + 35, id(info), id(white), "%.1f C", id(int2_temp).state);
        else it.print(CARD_X + 50, C2_Y + 35, id(info), id(white), "-- C");
        if (id(int2_hum).has_state()) it.printf(CARD_X + 140, C2_Y + 35, id(info), id(white), "%.0f %%", id(int2_hum).state);
        else it.print(CARD_X + 140, C2_Y + 35, id(info), id(white), "-- %");
      } else {
        // Page 3: 3D Printer — App style
        it.printf(CX, TITLE_Y - 10, id(info), id(white), TextAlign::CENTER, "%s — %s", "${i18n_printer_title}", "${printer_brand}");
        
        // Section haute: Icône imprimante + Nom de fichier
        const int ICON_Y = 90;
        
        // Icône imprimante 3D (à gauche)
        it.image(30, ICON_Y - 20, id(printer3d), id(blue));
        
        // Nom de fichier avec défilement (droite)
        if (id(current_file).has_state()) {
          static char filename_buf[64];
          static int scroll_pos = 0;
          static unsigned long last_scroll = 0;
          const char* fname = id(current_file).state.c_str();
          int len = strlen(fname);
          const int MAX_DISPLAY_CHARS = 28;
          
          if (len <= MAX_DISPLAY_CHARS) {
            // Pas de défilement nécessaire
            it.printf(W - 135, ICON_Y - 15, id(info), id(white), TextAlign::TOP_LEFT, "%s", fname);
            scroll_pos = 0;
          } else {
            // Défilement nécessaire
            if (millis() - last_scroll > 150) {
              scroll_pos++;
              if (scroll_pos > len - MAX_DISPLAY_CHARS) scroll_pos = 0;
              last_scroll = millis();
            }
            strncpy(filename_buf, fname + scroll_pos, MAX_DISPLAY_CHARS);
            filename_buf[MAX_DISPLAY_CHARS] = '\0';
            it.printf(W - 135, ICON_Y - 15, id(info), id(white), TextAlign::TOP_LEFT, "%s", filename_buf);
          }
        } else {
          it.print(W - 135, ICON_Y - 15, id(info), id(white), TextAlign::TOP_LEFT, "--");
        }
        
        // État (sous le nom de fichier)
        if (id(print_status).has_state()) {
          it.printf(W - 135, ICON_Y + 5, id(info), id(white), TextAlign::TOP_LEFT, "%s", id(print_status).state.c_str());
        } else {
          it.print(W - 135, ICON_Y + 5, id(info), id(white), TextAlign::TOP_LEFT, "--");
        }
        
        // Barre de progression (centrée, sous l'icône et info)
        const int BAR_Y = 130;
        const int BAR_W = 200, BAR_H = 24, BAR_X = (W - BAR_W) / 2;
        it.filled_rectangle(BAR_X, BAR_Y, BAR_W, BAR_H, id(card_bg));
        it.rectangle(BAR_X, BAR_Y, BAR_W, BAR_H, id(divider));
        if (id(print_progress).has_state()) {
          float p = id(print_progress).state;
          if (p < 0) p = 0; if (p > 100) p = 100;
          int fill = (int)((BAR_W - 4) * (p / 100.0f));
          if (fill > 0) it.filled_rectangle(BAR_X + 2, BAR_Y + 2, fill, BAR_H - 4, id(blue));
        }
        // Pourcentage au centre de la barre (dessiné après le remplissage)
        if (id(print_progress).has_state()) {
          float p = id(print_progress).state;
          if (p < 0) p = 0; if (p > 100) p = 100;
          it.printf(CX, BAR_Y + 12, id(info), id(white), TextAlign::CENTER, "%.0f%%", p);
        } else {
          it.print(CX, BAR_Y + 12, id(info), id(white), TextAlign::CENTER, "--%");
        }

        // Grille d'informations (style météo)
        const int GRID_START_Y = 165;
        const int ROW_HEIGHT = 22;
        const int COL1_X = 15;
        const int COL2_X = 125;
        const int TEXT_OFFSET = 22;
        
        // Ligne 1: Temps restant | Heure de fin
        it.image(COL1_X, GRID_START_Y, id(timer_small), id(blue));
        if (id(time_remaining).has_state()) {
          it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s min", id(time_remaining).state.c_str());
        } else {
          it.print(COL1_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "-- min");
        }
        
        it.image(COL2_X, GRID_START_Y, id(clock_end_small), id(blue));
        if (id(end_time).has_state()) {
          // Extraire seulement HH:MM du format complet
          std::string end_str = id(end_time).state;
          size_t space_pos = end_str.find(' ');
          if (space_pos != std::string::npos && end_str.length() > space_pos + 5) {
            std::string time_part = end_str.substr(space_pos + 1, 5); // HH:MM
            it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s", time_part.c_str());
          } else {
            it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%s", id(end_time).state.c_str());
          }
        } else {
          it.print(COL2_X + TEXT_OFFSET, GRID_START_Y + 10, id(info), id(white), TextAlign::CENTER_LEFT, "--:--");
        }
        
        // Ligne 2: Température buse | Température lit
        it.image(COL1_X, GRID_START_Y + ROW_HEIGHT, id(nozzle_small), id(blue));
        if (id(nozzle_temp).has_state()) {
          if (id(nozzle_temp_set).has_state()) {
            it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f/%.0f°", id(nozzle_temp).state, id(nozzle_temp_set).state);
          } else {
            it.printf(COL1_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f°", id(nozzle_temp).state);
          }
        } else {
          it.print(COL1_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "--°");
        }
        
        it.image(COL2_X, GRID_START_Y + ROW_HEIGHT, id(bed_small), id(blue));
        if (id(bed_temp).has_state()) {
          if (id(bed_temp_set).has_state()) {
            it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f/%.0f°", id(bed_temp).state, id(bed_temp_set).state);
          } else {
            it.printf(COL2_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "%.0f°", id(bed_temp).state);
          }
        } else {
          it.print(COL2_X + TEXT_OFFSET, GRID_START_Y + ROW_HEIGHT + 10, id(info), id(white), TextAlign::CENTER_LEFT, "--°");
        }
      }
      // Indicateur de page (• • •) en bas
      const int DOTS = 3;
      const int DOT_RADIUS = 3;
      const int DOT_SPACING = 18;
      const int DOT_Y = H - M - 8;
      const int DOT_START_X = CX - DOT_SPACING;
      for (int i = 0; i < DOTS; i++) {
        int dx = DOT_START_X + i * DOT_SPACING;
        auto col = (i == page) ? id(blue) : id(grey);
        it.filled_circle(dx, DOT_Y, DOT_RADIUS, col);
      }
